<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>视频生成界面</title>
    <link rel="stylesheet" href="css/mainboard.css">
    <script src="https://unpkg.com/pinyin-pro"></script>
</head>
<body>
    <!-- 遮罩-->
    <div id="overlay" class="overlay"></div>
    <!-- 加载动画-->
    <div id="loading-overlay" class="loading-overlay" style="display: none;">
        <div class="loading-spinner"></div>
        <p>生成中，请稍候...</p>
    </div>
    <!-- 语音设置面板-->
    <div id="video-setting-panel" class="video-setting-panel">
        <div class="video-setting-head"> 
            <button id="voice-set-close-btn" class="close-btn">
                <img src="images/btn_back.png" alt="返回" class="close-icon">
            </button>
            <label>语音设置</label>
        </div>
        <div class="select-container">
            <label for="lang-select">语言选择</label>
            <select name="lang" id="lang-select" class="select">
                <option value="Chinese">中文</option>
                <option value="English">英文</option>
                <option value="Chinese-English Mixed">中英混合</option>
                <option value="Japanese">日语</option>
                <option value="Korean">韩语</option>
                <option value="Yue">粤语</option>
            </select>
        </div>
        <div class="select-container">
            <label for="lang-select">语言切分</label>
            <select name="lang" id="cut-select" class="select">
                <option value="Slice once every 4 sentences">凑四句一切</option>
                <option value="Slice per 50 characters">50字符一切</option>
                <option value="Slice by Chinese punct">按中文标点切分</option>
                <option value="Slice by English punct">按英文标点切分</option>
                <option value="Slice by every punct">按每个标点符号切分</option>
                <option value="No slice">不切分</option>
            </select>
        </div>
        <div class="select-container">
            <div class="slider-all-wrapper">
                <label >语速</label>
                <div class="slider-wrapper">
                    <span>0.6</span>
                    <input id="voice-speed-slider" type="range" min="0.6" max="1.6" step="0.1" value="1" class="slider">
                    <div id="voice-speed-tooltip" class="tooltip">1</div>
                    <span>1.6</span>
                </div>
            </div>
        </div>
        <div class="select-container">
            <div class="slider-all-wrapper">
                <label >温度</label>
                <div class="slider-wrapper">
                    <span>0</span>
                    <input id="voice-temp-slider" type="range" min="0" max="1" step="0.1" value="1" class="slider">
                    <div id="voice-temp-tooltip" class="tooltip">1</div>
                    <span>1</span>
                </div>
            </div>
        </div>
        <div class="button-container">
            <button class="process-main-btn" id="save-voice-setting-btn">确定</button>
        </div>
    </div>
    <!-- 动作设置面板-->
    <div id="motion-setting-panel" class="video-setting-panel">
        <div class="video-setting-head"> 
            <button id="motion-set-close-btn" class="close-btn">
                <img src="images/btn_back.png" alt="返回" class="close-icon">
            </button>
            <label>动作自定义</label>
        </div>
        <div class="motion-set-container">
            <p>输入动作描述词</p>
            <textarea placeholder="一个男人，演讲，比划手势" id="motion-gen-prompt" class="show-text-panel"></textarea>
            <div class="checkbox-container">
                <p>视频补帧</p>
                <input type="checkbox" class="lip-choose-box" id="motion-lerp" checked>
                <label for="motion-lerp"></label>
            </div>
        </div>
        <div class="button-container">
            <p id="motion-time">视频时长：4.56s</p>
            <button class="process-main-btn" id="save-motion-setting-btn">确定</button>
        </div>
    </div>
    <!-- 新增的顶部导航栏 -->
    <nav class="top-nav">
      <div class="left-section">
        <img src="images/LOGO.png" alt="Logo" class="logo">
        <button class="menu-btn">菜单</button>
      </div>
      <div class="nav-center">
        <p class="center-text">工作台</p>
      </div>
      <div class="right-section">
        <button class="preview-btn" id="preview-btn">
            预览
            <img src="images/goahead-btn.png" alt="预览图标" class="preview-icon">
        </button>
      </div>
    </nav>

    <div class="container">
        <div class="content-wrapper">
            <div class="list-left-head">
                <p>镜头列表</p>
            </div>
            <!-- 左侧镜头列表 -->
            <div class="left-panel">
                <div class="camera-item">
                    <span class="camera-number">1</span>
                    <img src="images/sceneimg.png" alt="1" class="sceneimg">
                    <p class="camera-description">想象一下，如果没有重力会...</p>
                </div>
            </div>
        </div>

        <!-- 中部 -->
        <div class="main-panel">
            <!-- 视频编辑面板 -->
            <div class="vieo-head">
                <p>播放器</p>
                <button id="video-setting">
                    <img src="images/btn_videoset.png" alt="设置">
                </button>
            </div>
            <div class="video-player-panel">
                <!-- 视频编辑容器 -->
                <div class="video-container">
                    <div id="editor"></div>
                </div>
                <div class="range-container">
                    <input class="video-range" type="range" id="videoProgress" value="0" min="0" max="100" step="0.1" >
                </div>
                <div class="player-controls">
                    <div class="time-display">
                        <span id="currentTime">00:00:00.00</span> / <span id="duration">00:00:00.00</span>
                    </div>
                    <div class="play-button-container">
                        <button id="play-this-video">
                            <img src="images/btn_play.png" alt="播放" id="play-icon">
                        </button>
                    </div>
                    <div class="ratio-button-container">
                        <button id="ratio-button">比例</button>
                    </div>    
                </div>
            </div>
            <!-- 文字处理面板 -->
            <div class="process-panel">
                <div class="text-head">
                    <div class="custom-select">
                        <select id="choose-voice">
                            <option value="voice1">女声</option>
                            <option value="voice2">男声</option>
                            <!-- 可以根据需要添加更多选项 -->
                        </select>
                        <select id="choose-char">
                        </select>
                    </div>
                    <div class="voice-gen-btn-container">
                        <button id="voice-gen-btn">语音生成</button>
                        <button id="motion-gen-btn">动作生成</button>
                        <button id="wav2lip-gen-btn">口型匹配</button>
                    </div>
                    <div>
                        <button class="video-gen-setting" id="video-gen-setting">设置</button>
                    </div>
                </div>
                <!-- 音频列表 -->
                <div class="process-tab-container" id="voice-tab-container">
                    <div class="process-tab-content">
                        <div class="process-input-container">
                            <textarea placeholder="请输入生成文本" id="show-text-panel" class="show-text-panel"></textarea>
                            <div id="show-emo-panel" class="show-text-panel"></div>
                        </div>
                        <div class="process-btn-container">
                            <button class="process-grey-btn" id="emo-analysis-btn">文本解析</button>
                            <button class="process-main-btn" id="text-to-audio-btn" style="display: none;">生成语音</button>
                        </div>
                    </div>
                    <div class="wav-edit-panel">
                        <div class="wav-head">
                            <p>录音编辑</p>
                        </div>
                        <div class="wav-range-container">
                            <div class="audio-container" id="audio-container">
                            </div>
                            <div class="audio-controls">
                                <button id="audio-del-btn">删除</button>
                                <button id="audio-replace-btn">重生片段</button>
                            </div>
                        </div>      
                    </div>
                </div>
                <!-- 动作列表 -->
                <div class="process-tab-container" id="motion-tab-container">
                    <div class="process-tab-content">
                        <div id="show-motion-panel" class="show-text-panel">
                        </div>
                        <div class="motion-preview-panel" id="motion-preview-panel">
                            <p style="color: rgba(255,255,255,0.75);font-size: 14px;">暂无数据，点击姿态预览按钮进行预览</p>
                        </div>
                        <div class="process-btn-container">
                            <button class="process-grey-btn" id="motion-pose-pre">姿态预览</button>
                            <button class="process-main-btn" id ="motion-render-pre">角色渲染</button>
                        </div>
                    </div>
                </div>
                <!-- 口型匹配列表 -->
                <div class="process-tab-container" id="wav2lip-tab-container">
                    <div class="process-tab-content">
                        <div class="lip-gen-panel">
                            <div class="lip-text-choose-panel">
                                <textarea placeholder="请输入生成文本" id="show-liptext-panel" class="show-text-panel" readonly style="pointer-events: none;"></textarea>
                            </div>
                            <div id="lip-show-panel" class="show-text-panel" style="display: none;">
                                <video id="char-video" controls style="max-height: 110px; border-radius: 4px;">
                            </div>
                        </div>
                        <div class="lip-gen-ctrl-panel">
                            <div class="slider-container" id="slider-container1">
                                <div class="slider-label">嘴部开合</div>
                                <div class="slider-wrapper">
                                    <span>-9</span>
                                    <input id="slider1" type="range" min="-9" max="9" step="1" value="0" class="slider">
                                    <div id="tooltip1" class="tooltip">0</div>
                                    <span>9</span>
                                </div>
                            </div>
                            <div class="slider-container" id="slider-container2">
                                <div class="slider-label">处理批次(默认不变)</div>
                                <div class="slider-wrapper">
                                    <span>1</span>
                                    <input id="slider2" type="range" min="1" max="8" step="1" value="8" class="slider">
                                    <div id="tooltip2" class="tooltip">1</div>
                                    <span>8</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="process-btn-container">
                            <button class="process-grey-btn" id="wavtolip-apply-btn">预览</button>
                            <button class="process-main-btn" id="wavtolip-ensure-btn" style="display: none;">应用</button>
                        </div>
                    </div>    
                </div>
            </div>
        </div>
        
        <div class="content-wrapper">
            <!-- 当前素材列表面板 --> 
            <div class="part-material-panel">
                <div class="part-list-head">
                    <p id="part-scene-index">当前分镜素材-01</p>
                </div>
                <div class="part-tabs">
                    <button class="part-tab-button active" data-tab="part-images">图片</button>
                    <button class="part-tab-button" data-tab="part-characters">角色</button>
                </div>
                <div class="part-tab-content active" id="part-images">
                    <div class="apply-img-material">
                    </div>
                </div>
                <div class="part-tab-content" id="part-characters">
                </div>
                <div class="part-blender-btn-container">
                    <button class="blend-part-img-btn">A I融合</button>
                </div>
            </div>
            <!-- 素材库面板 --> 
            <div class="all-material-panel">
                <div class="all-list-head">
                    <p>素材库</p>
                </div>
                <div class="all-tabs">
                    <button class="all-tab-button active" data-tab="all-images">图片</button>
                    <button class="all-tab-button" data-tab="all-characters">角色</button>
                </div>
                <div class="all-tab-content active" id="all-images">
                    <div class="content-list" id="all-img-list">
                        <div class="ori-img-material">
                            <p>01</p>
                            <p class="all-img-name">背景</p>
                            <button class="edit-all-img-btn" id="addtopart-mat-btn">添加</button>
                            <button class="del-all-img-btn">删除</button>
                        </div>
                    </div>
                    <div >
                        <button class="create-all-img-btn" id="create-all-img-btn">新建图片</button>
                    </div>
                </div>
                <div class="all-tab-content" id="all-characters">
                    <div class="content-list" id="all-char-list">
                    </div>
                    <div>
                        <button class="add-all-cha-btn" id="add-all-cha-btn">新建角色</button>
                    </div>
                </div>

            </div>
        </div>
    </div> 
    <script >

        document.addEventListener('DOMContentLoaded', function() {
            const overlay = document.getElementById('overlay');
            const loadingOverlay = document.getElementById('loading-overlay');
            let selectedCameraItem = null; // 用于存储当前选中的 camera-item
            let selectedSceneIndex = -1; // 用于存储当前选中的 sceneIndex

            // 在页面加载时删除 audio-container 下的所有 audio-material
            function deleteAllAudioMaterial() {
                const audioContainer = document.getElementById('audio-container');
                const audioMaterials = audioContainer.querySelectorAll('.audio-material');
                audioMaterials.forEach(material => {   
                    material.remove();
                });
            }
            // 镜头列表面板
            async function loadStoryboardData() { // 获取并加载分镜数据
                const leftPanel = document.querySelector('.left-panel');
                leftPanel.innerHTML = '';
                try {
                    // 读取现有的 JSON 数据
                    const response = await fetch('/read-json-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            fileName: 'storyboard.json'
                        })
                    });
                    const data = await response.json();
                    const scenes = data.scenes;
                    // 遍历 scenes 对象并创建 camera-item
                    for (const [key, value] of Object.entries(scenes)) {
                        const cameraItem = document.createElement('div');
                        cameraItem.className = 'camera-item';
                        cameraItem.setAttribute('data-index', key); // 存储索引
                        const cameraNumber = document.createElement('span');
                        cameraNumber.className = 'camera-number';
                        cameraNumber.textContent = parseInt(key) + 1;
                        const sceneImg = document.createElement('img');
                        sceneImg.src = "images/sceneimg.png"; 
                        sceneImg.alt = key;
                        sceneImg.className = 'sceneimg';
                        const description = document.createElement('p');
                        description.className = 'camera-description'; 
                        description.textContent = value;
                        cameraItem.appendChild(cameraNumber);
                        cameraItem.appendChild(sceneImg);
                        cameraItem.appendChild(description);
                        leftPanel.appendChild(cameraItem);
                        // 切换分镜
                        cameraItem.addEventListener('click', async function() {
                            const partsceneindex = document.getElementById('part-scene-index');
                            const allCameraItems = document.querySelectorAll('.camera-item');
                            const showTextPanel = document.getElementById('show-text-panel');
                            const showLipTextPanel = document.getElementById('show-liptext-panel');
                            allCameraItems.forEach(item => item.classList.remove('selected'));
                            cameraItem.classList.add('selected');
                            showTextPanel.value = description.textContent; 
                            showLipTextPanel.value = description.textContent;
                            selectedCameraItem = cameraItem;
                            selectedSceneIndex = parseInt(cameraItem.getAttribute('data-index'), 10); // 获取索引
                            partsceneindex.textContent = "当前分镜素材-"+(selectedSceneIndex + 1).toString().padStart(2, '0');
                            saveStoryboardData();
                            UpdateMotiontext();
                            // 更新播放器
                            await updateAudioPlayers();
                            //更新当前素材-素材列表
                            await getThisPageMatImages();
                            // 获取当前素材-角色图片
                            await getThisPageCharImages();
                            // 更新视频编辑器
                            const currentSceneLayers = layers.filter(layer => layer.getAttribute('sceneindex') === selectedSceneIndex.toString());
                            const editor = document.getElementById('editor');
                            editor.innerHTML = ''; // 清空 editor
                            // 按 layerIndex 排序 layers 数组
                            currentSceneLayers.sort((a, b) => {
                                const aIndex = parseInt(a.getAttribute('layerindex'), 10);
                                const bIndex = parseInt(b.getAttribute('layerindex'), 10);
                                return aIndex - bIndex;
                            });                    
                            currentSceneLayers.forEach(layer => {
                                editor.appendChild(layer);
                            });
                        });
                    }
                    // 默认选择第一个 camera-item
                    const firstCameraItem = leftPanel.querySelector('.camera-item');
                    if (firstCameraItem) {
                        firstCameraItem.click();
                    }
                } catch (error) {
                    console.error('加载分镜数据失败:', error);
                }
            }
            // 加载分镜数据
            loadStoryboardData(); 
            // 输入分镜描述时更新分镜描述
            const showTextPanel = document.getElementById('show-text-panel');
            showTextPanel.addEventListener('input', function() {
                if (selectedCameraItem) {
                    const description = selectedCameraItem.querySelector('.camera-description');
                    if (description) {
                        description.textContent = showTextPanel.value; 
                        saveStoryboardData();
                    }
                }
            });
            // 保存更新后的描述内容到 data/storyboard.json
            async function saveStoryboardData() {
                const leftPanel = document.querySelector('.left-panel');
                const cameraItems = leftPanel.querySelectorAll('.camera-item');
                const scenes = {};
                cameraItems.forEach((item, index) => {
                    const description = item.querySelector('.camera-description');
                    if (description) {
                        scenes[index] = description.textContent;
                    }
                });
                const data = { scenes };
                try {
                    const response = await fetch('/save-storyboard', { 
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(data)
                    });
                    if (!response.ok) {
                        throw new Error('保存数据失败');
                    }
                } catch (error) {
                    console.error('保存数据失败:', error);
                }
            }

            //素材库面板
            const allTabButtons = document.querySelectorAll('.all-tab-button');// 处理素材库all-tabs 的点击事件
            const allTabContents = document.querySelectorAll('.all-tab-content');
            allTabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const targetTab = button.getAttribute('data-tab');
                    // 移除所有按钮的激活状态
                    allTabButtons.forEach(btn => btn.classList.remove('active'));
                    // 移除所有内容区域的激活状态
                    allTabContents.forEach(content => content.classList.remove('active'));
                    // 激活当前按钮和对应的内容区域
                    button.classList.add('active');
                    document.getElementById(targetTab).classList.add('active');
                });
            });
            // 删除素材库图片文件函数
            async function deleteImageFile(FloderName, fileName) {
                try {
                    const response = await fetch('/delete-image-file', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ FloderName: FloderName, fileName: fileName })
                    });
                    if (!response.ok) {
                        throw new Error('Network response was not ok ' + response.statusText);
                    }
                    const data = await response.json();
                    return data;
                } catch (error) {
                    console.error('There was a problem with the fetch operation:', error);
                    throw error;
                }
            }

            //素材库面板-角色
            // 选择角色的下拉菜单添加 change 事件监听器
            const selectCharElement = document.getElementById('choose-char');
            let selectedCharValue = '';
            // 获取素材库-角色图片
            getGeneratedCharImages();
            async function getGeneratedCharImages() {
                const FloderName = "character";  // 你可以根据需要更改文件夹名称
                try {
                    const response = await fetch('/get_gen_image', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ FloderName: FloderName })
                    });
                    if (!response.ok) {
                        throw new Error('Network response was not ok ' + response.statusText);
                    }
                    const data = await response.json();
                    if (data.files) {
                        updateCharacterList(data.files);
                        updateCharacterSelect(data.files)
                    } else {
                        console.error('Unexpected response format:', data);
                    }
                } catch (error) {
                    console.error('There was a problem with the fetch operation:', error);
                    alert('获取图片失败，请重试');
                }
            }
            // 更新选择角色的下拉菜单
            function updateCharacterSelect(fileNames) {
                const selectElement = document.getElementById('choose-char');
                selectElement.innerHTML = ''; 
                fileNames.forEach(fileName => {
                    const optionElement = document.createElement('option');
                    optionElement.value = fileName;
                    optionElement.textContent = fileName.replace(/\.png$/, '');  // 去掉文件名中的 .png 后缀
                    // 将 option 元素添加到 select 元素中
                    selectElement.appendChild(optionElement);
                });
                if (selectCharElement.options.length > 0) {
                    selectedCharValue = selectCharElement.options[0].value;
                    console.log('默认选中的角色:', selectedCharValue);
                }
            }
            // 更新素材库-角色列表
            function updateCharacterList(fileNames) {
                const allCharactersContainer = document.getElementById('all-char-list');
                allCharactersContainer.innerHTML = '';  // 清除现有的角色列表
                fileNames.forEach(fileName => {
                    // 创建一个新的 div 容器
                    const oriChaMaterialDiv = document.createElement('div');
                    oriChaMaterialDiv.className = 'ori-cha-material';
                    const imgElement = document.createElement('img');
                    imgElement.src = `data/character/${fileName}`;
                    imgElement.alt = "png";
                    imgElement.className = 'icon';
                    const nameElement = document.createElement('p');
                    nameElement.className = 'all-cha-name';
                    const displayName = fileName.replace(/\.png$/, '');
                    nameElement.textContent = displayName;
                    // 创建编辑按钮
                    const editButton = document.createElement('button');
                    editButton.className = 'edit-all-cha-btn';
                    editButton.textContent = '编辑';
                    // 创建删除按钮
                    const deleteButton = document.createElement('button');
                    deleteButton.className = 'del-all-cha-btn';
                    deleteButton.textContent = '删除';
                    // 为删除按钮添加点击事件监听器
                    deleteButton.addEventListener('click', function() {
                        // 调用删除函数
                        deleteImageFile("character", fileName).then(response => {
                            if (response.message) {
                                getGeneratedCharImages();
                                // allCharactersContainer.removeChild(oriChaMaterialDiv);
                            }
                        }).catch(error => {
                            console.error('删除文件失败:', error);
                        });
                    });
                    // 将 img 元素添加到 div 容器中
                    oriChaMaterialDiv.appendChild(imgElement);
                    oriChaMaterialDiv.appendChild(nameElement);
                    oriChaMaterialDiv.appendChild(editButton);
                    oriChaMaterialDiv.appendChild(deleteButton);
                    // 将 div 容器添加到 all-characters 容器中
                    allCharactersContainer.appendChild(oriChaMaterialDiv);
                });
            }

            // 素材库面板-素材
            //获取素材库-素材图片
            getGeneratedMatImages();
            async function getGeneratedMatImages() {
                const FloderName = "material";  // 你可以根据需要更改文件夹名称
                try {
                    const response = await fetch('/get_gen_image', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ FloderName: FloderName })
                    });
                    if (!response.ok) {
                        throw new Error('Network response was not ok ' + response.statusText);
                    }
                    const data = await response.json();
                    if (data.files) {
                        updateMaterialList(data.files);
                    } else {
                        console.error('Unexpected response format:', data);
                    }
                } catch (error) {
                    console.error('There was a problem with the fetch operation:', error);
                    alert('获取图片失败，请重试');
                }
            }
            // 更新素材库-素材列表
            function updateMaterialList(fileNames) {
                const allMatContainer = document.getElementById('all-img-list');
                allMatContainer.innerHTML = '';  // 清除现有的角色列表
                fileNames.forEach(fileName => {
                    // 创建一个新的 div 容器
                    const oriImgMaterialDiv = document.createElement('div');
                    oriImgMaterialDiv.className = 'ori-img-material';
                    const imgElement = document.createElement('img');
                    imgElement.src = `data/material/${fileName}`;
                    imgElement.alt = "png";
                    imgElement.className = 'icon';
                    const nameElement = document.createElement('p');
                    nameElement.className = 'all-img-name';
                    const displayName = fileName.replace(/\.png$/, '');
                    nameElement.textContent = displayName;
                    // 创建添加按钮
                    const addButton = document.createElement('button');
                    addButton.className = 'add-all-img-btn';
                    addButton.textContent = '添加';
                    // 为添加按钮添加点击事件监听器
                    addButton.addEventListener('click', function() {
                        addImageToPartMaterial(fileName).then(response => {

                        });
                    });
                    // 创建删除按钮
                    const deleteButton = document.createElement('button');
                    deleteButton.className = 'del-all-img-btn';
                    deleteButton.textContent = '删除';
                    // 为删除按钮添加点击事件监听器
                    deleteButton.addEventListener('click', function() {
                        deleteImageFile("material", fileName).then(response => {
                            if (response.message) {
                                getGeneratedMatImages();
                            }
                        }).catch(error => {
                            console.error('删除文件失败:', error);
                        });
                    });
                    // 将 img 元素添加到 div 容器中
                    oriImgMaterialDiv.appendChild(imgElement);
                    oriImgMaterialDiv.appendChild(nameElement);
                    oriImgMaterialDiv.appendChild(addButton);
                    oriImgMaterialDiv.appendChild(deleteButton);
                    // 将 div 容器添加到 all-characters 容器中
                    allMatContainer.appendChild(oriImgMaterialDiv);
                });
            }

            //当前素材面板
            const partTabButtons = document.querySelectorAll('.part-tab-button');// 处理当前素材part-tabs 的点击事件
            const partTabContents = document.querySelectorAll('.part-tab-content');
            partTabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const targetTab = button.getAttribute('data-tab');
                    // 移除所有按钮的激活状态
                    partTabButtons.forEach(btn => btn.classList.remove('active'));
                    partTabContents.forEach(content => content.classList.remove('active'));
                    // 激活当前按钮和对应的内容区域
                    button.classList.add('active');
                    document.getElementById(targetTab).classList.add('active');
                });
            });

            //初始化视频编辑器列表
            getThisPageVideoMaterial();

            getThisPageMatImages();
            // 获取当前素材-素材图片
            async function getThisPageMatImages() {
                try {
                    // 读取现有的 JSON 数据
                    const response = await fetch('/read-json-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            fileName: 'Material_data.json'
                        })
                    });
                    const data = await response.json();
                    const thisPageMatImages = data[selectedSceneIndex.toString()];
                    if (thisPageMatImages) {
                        update_this_MaterialList(thisPageMatImages);
                    }
                }
                catch (error) {
                    console.error('There was a problem with the fetch operation:', error);
                }
            }
            //更新当前素材-素材列表
            function update_this_MaterialList(fileNames) {

                const this_MatContainer = document.getElementById('part-images');
                this_MatContainer.innerHTML = '';  // 清除现有的角色列表
                fileNames.forEach(fileName => {
                    const truefilename = fileName.replace(/(\d+)(?=\.\w+$)/, '');
                    // console.log(fileName,"to",truefilename);
                    // 创建一个新的 div 容器
                    const this_ImgMaterialDiv = document.createElement('div');
                    this_ImgMaterialDiv.className = 'apply-img-material';
                    const imgElement = document.createElement('img');
                    imgElement.src = `data/material/${truefilename}`;
                    imgElement.alt = "png";
                    imgElement.className = 'icon';
                    const nameElement = document.createElement('p');
                    nameElement.className = 'part-img-name';
                    const displayName = fileName.split('.')[0];
                    nameElement.textContent = displayName;
                    // 创建编辑按钮
                    const editButton = document.createElement('button');
                    editButton.className = 'edit-part-img-btn';
                    editButton.textContent = '编辑';
                    // 为添加按钮添加点击事件监听器
                    editButton.addEventListener('click', function() {
                        console.log('编辑按钮被点击');
                    });
                    const deleteButton = document.createElement('button');
                    deleteButton.className = 'del-part-img-btn';
                    deleteButton.textContent = '删除';
                    // 当前素材-删除按钮
                    deleteButton.addEventListener('click', function() {
                        delete_this_ImageFile(fileName).then(response => {
                            if (response.message) {
                                getThisPageMatImages();     
                            }
                        }).catch(error => {
                            console.error('删除文件失败:', error);
                        });
                    });
                    this_ImgMaterialDiv.appendChild(imgElement);
                    this_ImgMaterialDiv.appendChild(nameElement);
                    this_ImgMaterialDiv.appendChild(editButton);
                    this_ImgMaterialDiv.appendChild(deleteButton);
                    this_MatContainer.appendChild(this_ImgMaterialDiv);
                });
            }
            //删除当前素材-素材图片
            async function delete_this_ImageFile(fileName) {
                const SceneIndex = selectedSceneIndex.toString();
                try {
                    // 读取现有的 JSON 数据
                    const response = await fetch('/read-json-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            fileName: 'Material_data.json'
                        })
                    });
                    const data = await response.json();
                    const thisPageMatImages = data[SceneIndex];
                    if (thisPageMatImages && thisPageMatImages.length > 0) {
                        // 检查 fileName 是否在列表中，并删除它
                        const index = thisPageMatImages.indexOf(fileName);
                        if (index !== -1) {
                            thisPageMatImages.splice(index, 1);
                            data[SceneIndex] = thisPageMatImages;
                        }                        
                    }
                    // 将更新后的数据写回到 JSON 文件中
                    const updateResponse = await fetch('/save-json-data', {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            Jsondata: data,
                            fileName: 'Material_data.json'
                        })
                    });
                    if (!updateResponse.ok) {
                        throw new Error('更新数据失败');
                    }
                    removeLayer(fileName);//删除图层
                    return { message: '当前素材文件已删除' };        
                }
                catch (error) {
                    console.error('There was a problem with the fetch operation:', error);
                }
            }

            // 获取当前素材-角色图片
            getThisPageCharImages();
            async function getThisPageCharImages() {
                try {
                    // 读取现有的 JSON 数据
                    const response = await fetch('/get_genchar_video', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            selectedSceneIndex: selectedSceneIndex.toString()
                        })
                    });
                    const data = await response.json();
                    if (data.files) {
                        await update_this_CharList(data.files);
                        const filenames = data.files
                        if (Array.isArray(filenames)) {
                            for (const fileName of filenames) {
                                await addVideoMaterial('char_video',fileName,selectedSceneIndex.toString());
                            }
                        } else {
                            console.warn(`data for scene is not an array or is empty:`, filenames);
                        }
                        
                    } else {
                        console.error('Unexpected response format:', data);
                    }
                }
                catch (error) {
                    console.error('There was a problem with the fetch operation:', error);
                }
            }            
            //更新当前素材-角色列表
            function update_this_CharList(fileNames) {
                const this_CharContainer = document.getElementById('part-characters');
                this_CharContainer.innerHTML = '';  // 清除现有的角色列表
                fileNames.forEach(fileName => {
                    // 创建一个新的 div 容器
                    const this_CharDiv = document.createElement('div');
                    this_CharDiv.className = 'apply-cha-material';
                    const imgElement = document.createElement('img');
                    const charname = fileName.split('-')[1].split('.')[0];
                    console.log('charname', charname);
                    imgElement.src = `data/character/${charname}.png`;
                    imgElement.alt = "png";
                    imgElement.className = 'icon';
                    const nameElement = document.createElement('p');
                    nameElement.className = 'part-cha-name';
                    nameElement.textContent = charname;
                    // 创建删除按钮
                    const deleteButton = document.createElement('button');
                    deleteButton.className = 'del-part-cha-btn';
                    deleteButton.textContent = '删除';
                    // 为删除按钮添加点击事件监听器
                    deleteButton.addEventListener('click', function() {
                        delete_this_CharFile("char_video", fileName).then(response => {
                            if (response.message) {
                                getThisPageCharImages();
                            }
                        }).catch(error => {
                            console.error('删除文件失败:', error);
                        });
                    });
                    // 将 img 元素添加到 div 容器中
                    this_CharDiv.appendChild(imgElement);
                    this_CharDiv.appendChild(nameElement);
                    this_CharDiv.appendChild(deleteButton);
                    // 将 div 容器添加到 all-characters 容器中
                    this_CharContainer.appendChild(this_CharDiv);
                });
            }            
            //删除当前素材-角色图片
            async function delete_this_CharFile(FloderName,fileName) {
                try {
                    const response = await fetch('/delete-image-file', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ FloderName: FloderName, fileName: fileName })
                    });
                    if (!response.ok) {
                        throw new Error('Network response was not ok ' + response.statusText);
                    }
                    const data = await response.json();
                    removeLayer(fileName);//删除图层
                    return data;
                } catch (error) {
                    console.error('There was a problem with the fetch operation:', error);
                    throw error;
                }
            }


            //三个处理面板
            const voiceGenBtn = document.getElementById('voice-gen-btn');
            const VoiceSelect = document.getElementById('choose-voice');
            const motionGenBtn = document.getElementById('motion-gen-btn');
            const selectChar = document.getElementById('choose-char');
            const wav2lipGenBtn = document.getElementById('wav2lip-gen-btn');
            const voiceTabContainer = document.getElementById('voice-tab-container');
            const motionTabContainer = document.getElementById('motion-tab-container');
            const wav2lipTabContainer = document.getElementById('wav2lip-tab-container');
            //初始化操作
            selectChar.style.display = 'none';
            function hideAllTabs() {
                voiceTabContainer.style.display = 'none';
                motionTabContainer.style.display = 'none';
                wav2lipTabContainer.style.display = 'none';
            }
            function showTab(tabId, activeBtn) {
                hideAllTabs();
                document.getElementById(tabId).style.display = 'block';
                voiceGenBtn.classList.remove('active');
                motionGenBtn.classList.remove('active');
                wav2lipGenBtn.classList.remove('active');
                activeBtn.classList.add('active');
            }
            voiceGenBtn.addEventListener('click', function() {
                VoiceSelect.style.display = 'block';
                selectChar.style.display = 'none';
                showTab('voice-tab-container', voiceGenBtn);

            });
            motionGenBtn.addEventListener('click', function() {
                VoiceSelect.style.display = 'none';
                selectChar.style.display = 'block';
                showTab('motion-tab-container', motionGenBtn);

            });
            wav2lipGenBtn.addEventListener('click', function() {
                selectChar.style.display = 'none';
                showTab('wav2lip-tab-container', wav2lipGenBtn);
            });
            showTab('voice-tab-container', voiceGenBtn);
            //语音生成面板
            //语音生成tab

            //点击文本分析按钮
            const emoAnalysisBtn = document.getElementById('emo-analysis-btn');
            const texttoaudiobtn = document.getElementById('text-to-audio-btn');
            emoAnalysisBtn.addEventListener('click', async function() {
                // 获取当前选中的 camera-item 的描述内容
                if (selectedCameraItem) {
                    const description = selectedCameraItem.querySelector('.camera-description');
                    if (description) {
                        const textContent = description.textContent;
                        await analyzeText(textContent);
                        //显示生成语音按钮
                        texttoaudiobtn.style.display = 'block';
                    }
                } else {
                    alert('请先选择一个镜头');
                }
            });
            // 分析文本内容
            async function analyzeText(text) {
                loadingOverlay.style.display = 'flex'; // 显示加载图标
                console.log('分析文本内容:', text);
                try {
                    if (!text) {
                        throw new Error('文本内容为空');
                    }
                    const response = await fetch('/analyze-text', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ text: text })
                    });
                    if (!response.ok) {
                        throw new Error('Network response was not ok ' + response.statusText);
                    }
                    const data = await response.json();
                    displayAnalysisResult(data.text);
                    saveAnalyzedText(selectedSceneIndex,data.text);
                } catch (error) {
                    console.error('文本分析失败:', error);
                }
                finally {
                    loadingOverlay.style.display = 'none'; // 隐藏加载图标
                }
            }

            // 显示分析结果
            function displayAnalysisResult(text) {
                const inputpanel = document.getElementById('show-emo-panel');
                if (!inputpanel) {
                    console.error('Element with id "show-emo-panel" not found');
                    return;
                }
                inputpanel.style.display = 'block';
                inputpanel.innerHTML = '';
                // 解析文本，提取情绪和文字
                const regex = /([^()]+)\(([^)]+)\)/g;
                let lastIndex = 0;
                let match;
                while ((match = regex.exec(text)) !== null) {
                    // 添加匹配前的剩余文本
                    if (match.index > lastIndex) {
                        const remainingText = text.slice(lastIndex, match.index).trim();
                        if (remainingText) {
                            const remainingTextContainer = document.createElement('div');
                            remainingTextContainer.textContent = remainingText;
                            inputpanel.appendChild(remainingTextContainer);
                        }
                    }
                    const sentence = match[1].trim();
                    const emotion = match[2].trim();
                    // 创建包含句子和下拉列表的子div
                    const sentenceContainer = document.createElement('div');
                    sentenceContainer.className = 'sentence-container';
                    sentenceContainer.setAttribute('data-sentence', sentence);  // 添加数据属性
                    // 添加句子
                    const sentenceText = document.createTextNode(sentence);
                    sentenceContainer.appendChild(sentenceText);
                    // 创建下拉列表
                    const select = document.createElement('select');
                    select.className = 'emo-select';
                    select.onchange = function() {
                        console.log('Selected emotion:', this.value);
                        updateEmotion(sentence, this.value);
                    };
                    const emotions = ['平静', '兴奋', '悲伤', '疑惑', '激动'];
                    emotions.forEach(e => {
                        const option = document.createElement('option');
                        option.value = e;
                        option.textContent = e;
                        if (e === emotion) {
                            option.selected = true;
                        }
                        select.appendChild(option);
                    });
                    sentenceContainer.appendChild(select);
                    sentenceContainer.appendChild(document.createElement('br'));
                    inputpanel.appendChild(sentenceContainer);
                    lastIndex = regex.lastIndex;
                }
                // 添加剩余的文本
                if (lastIndex < text.length) {
                    const remainingText = text.slice(lastIndex).trim();
                    if (remainingText) {
                        const remainingTextContainer = document.createElement('div');
                        remainingTextContainer.textContent = remainingText;
                        inputpanel.appendChild(remainingTextContainer);
                    }
                }
            }

            // 更新情绪的函数
            function updateEmotion(sentence, newEmotion) {
                const inputPanel = document.getElementById('show-emo-panel');
                if (!inputPanel) {
                    console.error('Element with id "show-emo-panel" not found');
                    return;
                }
                const sentenceContainer = inputPanel.querySelector(`.sentence-container[data-sentence="${sentence}"]`);
                if (!sentenceContainer) {
                    console.error('Sentence container not found for sentence:', sentence);
                    return;
                }
                const select = sentenceContainer.querySelector('select');
                if (!select) {
                    console.error('Select element not found in sentence container');
                    return;
                }
                select.value = newEmotion;
                saveUpdatedEmotion(selectedSceneIndex);
            }
            // 保存更新后的情绪
            async function saveUpdatedEmotion(sceneIndex) {
                try {
                    // 获取 inputpanel 中的所有 sentence-container
                    const inputpanel = document.getElementById('show-emo-panel');
                    if (!inputpanel) {
                        console.error('Element with id "show-emo-panel" not found');
                        return;
                    }
                    const sentenceContainers = inputpanel.getElementsByClassName('sentence-container');
                    const data = [];
                    for (let i = 0; i < sentenceContainers.length; i++) {
                        const container = sentenceContainers[i];
                        const sentenceText = container.getAttribute('data-sentence').trim();  // 使用 data-sentence 属性
                        const select = container.querySelector('select');
                        if (select) {
                            const emotion = select.value;
                            data.push(`${sentenceText}(${emotion})`);
                        } else {
                            console.error('Select element not found in sentence container');
                        }
                    }
                    // 构建请求数据
                    const requestData = {
                        sceneIndex: sceneIndex.toString(),
                        text: data
                    };
                    // 发送请求到后端 API
                    const response = await fetch('/save-emotion-analysis', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestData)
                    });
                    if (!response.ok) {
                        throw new Error('保存分析结果失败: ' + response.statusText);
                    }
                    const result = await response.json();
                    console.log(result.message);  // 打印保存结果的消息
                } catch (error) {
                    console.error('保存分析结果失败:', error);
                }
            }            
            // 将分析结果保存到后端
            async function saveAnalyzedText(sceneIndex,text) {
                const sceneIndexStr = sceneIndex.toString();
                try {
                    const response = await fetch('/save-emotion-analysis', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            sceneIndex: sceneIndexStr,
                            text: text.split('\n').map(line => line.trim()).filter(line => line.length > 0)
                        })
                    });
                    if (!response.ok) {
                        throw new Error('保存分析结果失败: ' + response.statusText);
                    }
                    const result = await response.json();
                    console.log(result.message);  // 打印保存结果的消息
                } catch (error) {
                    console.error('保存分析结果失败:', error);
                }
            }
            
            // 语音设置面板和遮罩
            const langSelect = document.getElementById('lang-select'); 
            const cutSelect = document.getElementById('cut-select'); 
            const voicespeedslider = document.getElementById('voice-speed-slider'); // 滑块
            const voicetempslider = document.getElementById('voice-temp-slider');
            const voicespeedtooltip = document.getElementById('voice-speed-tooltip'); // Tooltip
            const voicetemptooltip = document.getElementById('voice-temp-tooltip');
            const settingButton = document.getElementById('video-gen-setting');
            const panel = document.getElementById('video-setting-panel');
            const closePanelButton = document.getElementById('voice-set-close-btn');
            const saveButton = document.getElementById('save-voice-setting-btn');
            // 保存当前的值
            let savedLangValue = langSelect.value;
            let savedCutValue = cutSelect.value;
            let savedVoiceSpeedValue = voicespeedslider.value;
            let savedVoiceTempValue = voicetempslider.value;
            function updatespeedTooltip() {
                const sliderRect = voicespeedslider.getBoundingClientRect();
                const sliderWidth = voicespeedslider.offsetWidth;
                const position = ((voicespeedslider.value - voicespeedslider.min) / (voicespeedslider.max - voicespeedslider.min)) * sliderWidth;
                voicespeedtooltip.style.left = `${position - voicespeedtooltip.offsetWidth / 2}px`; // 调整为 Tooltip 居中
                voicespeedtooltip.textContent = voicespeedslider.value; 
            }
            function updatetempTooltip() {
                const sliderRect = voicetempslider.getBoundingClientRect();
                const sliderWidth = voicetempslider.offsetWidth;
                const position = ((voicetempslider.value - voicetempslider.min) / (voicetempslider.max - voicetempslider.min)) * sliderWidth;
                voicetemptooltip.style.left = `${position - voicetemptooltip.offsetWidth / 2}px`; // 调整为 Tooltip 居中
                voicetemptooltip.textContent = voicetempslider.value; 
            }
            updatespeedTooltip();
            updatetempTooltip();
            voicespeedtooltip.style.opacity = 0;
            voicetemptooltip.style.opacity = 0;
            voicespeedslider.addEventListener('input', updatespeedTooltip);
            voicetempslider.addEventListener('input', updatetempTooltip);
            voicespeedslider.addEventListener('mouseenter', () => {
                updatespeedTooltip();
                voicespeedtooltip.style.opacity = 1;
            });
            voicespeedslider.addEventListener('mouseleave', () => voicespeedtooltip.style.opacity = 0);
            voicetempslider.addEventListener('mouseenter', () => {
                updatetempTooltip();
                voicetemptooltip.style.opacity = 1;
            });
            voicetempslider.addEventListener('mouseleave', () => voicetemptooltip.style.opacity = 0);
            // 打开面板和遮罩
            settingButton.addEventListener('click', function() {
                overlay.style.display = 'block';
                panel.style.display = 'block';
                // 保存当前的值
                savedLangValue = langSelect.value;
                savedCutValue = cutSelect.value;
                savedVoiceSpeedValue = voicespeedslider.value;
                savedVoiceTempValue = voicetempslider.value;
            });
            // 不更新值
            closePanelButton.addEventListener('click', function() {
                overlay.style.display = 'none';
                panel.style.display = 'none';
                langSelect.value = savedLangValue;
                cutSelect.value = savedCutValue;
                voicespeedslider.value = savedVoiceSpeedValue;
                voicetempslider.value = savedVoiceTempValue;
                updatespeedTooltip();
                updatetempTooltip();
            });
            //更新值
            saveButton.addEventListener('click', function() {
                overlay.style.display = 'none';
                panel.style.display = 'none';
                savedLangValue = langSelect.value;
                savedCutValue = cutSelect.value;
                savedVoiceSpeedValue = voicespeedslider.value;
                savedVoiceTempValue = voicetempslider.value;
                updatespeedTooltip();
                updatetempTooltip();
            });
            
            //点击语音生成按钮
            texttoaudiobtn.addEventListener('click', async function() {
                console.log('生成语音按钮被点击');
                try {
                    // 读取现有的 JSON 数据
                    const response = await fetch('/read-json-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            fileName: 'emotion_analysis.json'
                        })
                    });
                    const data = await response.json();
                    console.log('读取到的数据:', data);
                    // 提取 selectedSceneIndex 对应的值
                    const selectedSceneData = data[selectedSceneIndex.toString()];
                    if (!selectedSceneData) {
                        console.error('未找到对应的 selectedSceneIndex 数据');
                        return;
                    }
                    // 遍历每个 selectedSceneData 的值
                    selectedSceneData.forEach((item, index) => {
                        const match = item.match(/^(.+)\((.+)\)$/);
                        if (match) {
                            const text = match[1].trim();
                            const emotion = match[2].trim();
                            const tts_char = document.getElementById('choose-voice').value;
                            const output_name = selectedSceneIndex.toString()+'_'+index.toString()
                            // 发送数据到后端
                            sendToBackend(text, emotion, tts_char,output_name,savedLangValue,savedCutValue,savedVoiceSpeedValue,savedVoiceTempValue)
                        } else {
                            console.error('无法拆分文本和情绪:', item);
                        }
                    });
                } catch (error) {
                    console.error('读取文件时出错:', error);
                }
            });
            // 发送文本生成语音数据到后端
            async function sendToBackend(text, emotion,tts_char,output_name,savedLangValue,savedCutValue,savedVoiceSpeedValue,savedVoiceTempValue) {
                console.log('发送数据到后端:', text, emotion,tts_char,output_name,savedLangValue,savedCutValue,savedVoiceSpeedValue,savedVoiceTempValue);
                loadingOverlay.style.display = 'flex'; // 显示加载图标
                try {
                    const response = await fetch('/text-to-speech', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ text, emotion, tts_char, output_name,savedLangValue,savedCutValue,savedVoiceSpeedValue,savedVoiceTempValue})
                    });
                    if (!response.ok) {
                        throw new Error('后端响应失败');
                    }
                    const data = await response.json();
                    console.log('后端响应:', data.output_name);
                    // 重命名
                    const fileNameResponse = await fetch('/rename-audio-file', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ output_name })
                    });
                    if (!fileNameResponse.ok) {
                        throw new Error('获取文件名失败');
                    }
                    const fileNameData = await fileNameResponse.json();
                    console.log('文件名:', fileNameData.fileName);
                    // 更新播放器
                    await updateAudioPlayers();
                    loadingOverlay.style.display = 'none'; // 隐藏加载图标
                } catch (error) {
                    console.error('发送数据到后端时出错:', error);
                }

            }

            // 更新播放器函数
            async function updateAudioPlayers() {
                const audioContainer = document.getElementById('audio-container');
                audioContainer.innerHTML = '';
                try {
                    const audioFiles = await fetchAudioFiles();
                    // 检查 audioFiles 是否不为空
                    if (audioFiles && audioFiles.length > 0) {
                        audioFiles.forEach(fileName => createAudioPlayer(fileName));
                    }
                } catch (error) {
                    return;
                }
            }
            // 获取音频文件列表
            async function fetchAudioFiles() {
                const response = await fetch('/get-audio-files', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ selectedSceneIndex: selectedSceneIndex.toString() })
                });
                if (!response.ok) {
                    throw new Error('获取音频文件列表失败');
                }
                const data = await response.json();
                console.log('获取到的音频文件列表:', data.audio_files);
                return data.audio_files;
            }

            // 创建音频播放器函数
            function createAudioPlayer(fileName) {
                const audioMaterial = document.createElement('div');
                audioMaterial.className = 'audio-material';
                const audioPlayer = document.createElement('div');
                audioPlayer.className = 'audio-player';
                const playPauseBtn = document.createElement('button');
                playPauseBtn.className = 'audio-play-pause-btn';
                const playPauseImg = document.createElement('img');
                playPauseImg.src = 'images/btn_play.png';
                playPauseImg.alt = '播放';
                playPauseBtn.appendChild(playPauseImg);
                audioPlayer.appendChild(playPauseBtn);
                const audioProgressContainer = document.createElement('div');
                audioProgressContainer.className = 'audio-progress-container';
                const audioProgress = document.createElement('div');
                audioProgress.className = 'audio-progress';
                audioProgressContainer.appendChild(audioProgress);
                audioPlayer.appendChild(audioProgressContainer);
                audioMaterial.appendChild(audioPlayer);
                const audioElement = document.createElement('audio');
                const sourceElement = document.createElement('source');
                sourceElement.src = `data/audio/${fileName}`;
                sourceElement.type = 'audio/flac'; // 根据文件类型调整 MIME 类型
                audioElement.appendChild(sourceElement);
                audioElement.appendChild(document.createTextNode('您的浏览器不支持 audio 元素。'));
                audioMaterial.appendChild(audioElement);
                const audioContainer = document.getElementById('audio-container');
                if (audioContainer) {
                    audioContainer.appendChild(audioMaterial);
                } else {
                    console.error('audio-container 元素未找到');
                }

                // 选择音频
                const newAudioElements = document.querySelectorAll('audio');
                const newPlayPauseButtons = document.querySelectorAll('.audio-play-pause-btn');
                const newAudioPlayers = document.querySelectorAll('.audio-player');
                const newProgressContainers = document.querySelectorAll('.audio-progress-container');
                const newProgressBars = document.querySelectorAll('.audio-progress');
                const newIndex = newAudioElements.length - 1;
                newPlayPauseButtons[newIndex].addEventListener('click', function () {
                    const audio = newAudioElements[newIndex];
                    const progressBar = newProgressBars[newIndex];
                    if (audio.paused) {
                        // 如果当前音频是暂停状态，则播放当前音频
                        audio.play();
                        newPlayPauseButtons[newIndex].querySelector('img').src = "images/btn_pause.png"; // 切换为暂停图标
                        // 如果之前有其他音频在播放，则暂停它
                        if (currentPlayingAudioIndex !== null && currentPlayingAudioIndex !== newIndex) {
                            const otherAudio = newAudioElements[currentPlayingAudioIndex];
                            const otherButton = newPlayPauseButtons[currentPlayingAudioIndex];
                            otherAudio.pause();
                            otherButton.querySelector('img').src = "images/btn_play.png"; // 恢复播放图标
                        }
                        // 更新当前播放的音频索引
                        currentPlayingAudioIndex = newIndex;
                    } else {
                        // 如果当前音频是播放状态，则暂停当前音频
                        audio.pause();
                        newPlayPauseButtons[newIndex].querySelector('img').src = "images/btn_play.png"; // 切换为播放图标
                        
                        // 清除当前播放的音频索引
                        currentPlayingAudioIndex = null;
                    }
                    // 自动选择当前音频
                    selectAudio(newIndex);
                });

                // 绑定进度条点击事件
                newProgressContainers[newIndex].addEventListener('click', function (event) {
                    const audio = newAudioElements[newIndex];
                    const progressBar = newProgressBars[newIndex];
                    const progressWidth = newProgressContainers[newIndex].offsetWidth;
                    const clickPosition = event.offsetX; 
                    const newTime = (clickPosition / progressWidth) * audio.duration;
                    audio.currentTime = newTime;
                    progressBar.style.width = `${(audio.currentTime / audio.duration) * 100}%`;
                    selectAudio(newIndex);
                });
                // 动态更新进度条
                newAudioElements[newIndex].addEventListener('timeupdate', function () {
                    const progressBar = newProgressBars[newIndex];
                    progressBar.style.width = `${(newAudioElements[newIndex].currentTime / newAudioElements[newIndex].duration) * 100}%`; // 更新进度条宽度
                });
                newAudioElements[newIndex].addEventListener('ended', function () {
                    // 音频结束后恢复播放按钮图标
                    newPlayPauseButtons[newIndex].querySelector('img').src = "images/btn_play.png";
                    currentPlayingAudioIndex = null; // 清除播放索引
                });
            }

            let selectedAudioIndex = null; 
            let currentPlayingAudioIndex = null; 
            let selectedAudioFileName = null; 
            // 选择音频的方法
            function selectAudio(index) {
                // 重新获取所有音频播放器和进度条
                const audioPlayers = document.querySelectorAll('.audio-player');
                const progressBars = document.querySelectorAll('.audio-progress');
                const audioElements = document.querySelectorAll('audio');

                if (selectedAudioIndex !== null && selectedAudioIndex !== index) {
                    const previousPlayer = audioPlayers[selectedAudioIndex];
                    const previousProgressBar = progressBars[selectedAudioIndex];
                    if (previousPlayer) {
                        previousPlayer.style.border = ''; // 移除描边
                    }
                    if (previousProgressBar) {
                        previousProgressBar.style.backgroundColor = '#8785FF'; // 恢复原来的颜色
                    }
                }
                selectedAudioIndex = index;
                const currentPlayer = audioPlayers[index];
                const currentProgressBar = progressBars[index];
                const currentAudioElement = audioElements[index];
                if (currentPlayer) {
                    currentPlayer.style.border = '3px solid #6366f1'; // 增加描边
                }
                if (currentProgressBar) {
                    currentProgressBar.style.backgroundColor = '#6366f1'; // 修改进度条颜色
                }
                // 获取当前音频元素的 <source> 元素
                if (currentAudioElement) {
                    const sourceElement = currentAudioElement.querySelector('source');
                    if (sourceElement) {
                        const src = sourceElement.src;
                        const fileName = src.split('/').pop(); 
                        console.log('所选播放器的源音乐文件名:', fileName);
                        selectedAudioFileName = fileName; 
                    } else {
                        console.error('当前音频元素没有 <source> 元素');
                        selectedAudioFileName = null;
                    }
                } else {
                    console.error('当前音频元素未找到');
                    selectedAudioFileName = null; 
                }
            }

            // 删除按钮点击事件
            const audioDelBtn = document.getElementById('audio-del-btn');
            audioDelBtn.addEventListener('click', async function() {
                console.log('删除按钮被点击:' + selectedAudioFileName);
                if (selectedAudioFileName) {
                    try {
                        const response = await fetch('/delete-audio-file', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ fileName: selectedAudioFileName })
                        });
                        if (!response.ok) {
                            throw new Error('删除文件失败');
                        }
                        const data = await response.json();
                        console.log('文件删除成功:', data.message);
                        updateAudioPlayers()
                        const audioContainer = document.getElementById('audio-container');
                        const audioMaterials = audioContainer.querySelectorAll('.audio-material');
                        if (audioMaterials.length > 0) {
                            selectedAudioIndex = audioMaterials.length - 1;
                            selectAudio(selectedAudioIndex);
                        } else {
                            selectedAudioIndex = null;
                            selectedAudioFileName = null;
                            console.log('所有音频已删除');
                        }
                    } catch (error) {
                        console.error('删除文件时出错:', error);
                    }
                } else {
                    console.error('未选择音频文件');
                }
            });

            // 重新生成片段
            const audioReplaceBtn = document.getElementById('audio-replace-btn');
            audioReplaceBtn.addEventListener('click', async function() {
                console.log('重新生成片段按钮被点击:' + selectedAudioFileName);
                if (selectedAudioFileName) {
                    try {
                        // 读取现有的 JSON 数据
                        const response = await fetch('/read-json-data', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                fileName: 'emotion_analysis.json'
                            })
                        });
                        const data = await response.json();
                        const [key, index] = selectedAudioFileName.split('_');
                        const keyIndex = parseInt(key, 10);
                        const fileIndex = parseInt(index.split('.')[0], 10);
                        // 检查 key 和 index 是否有效
                        if (data.hasOwnProperty(keyIndex) && Array.isArray(data[keyIndex]) && fileIndex < data[keyIndex].length) {
                            const selectedData = data[keyIndex][fileIndex];
                            console.log('找到的数据:', selectedData);
                            const match = selectedData.match(/^(.+)\((.+)\)$/);
                            if (match) {
                                const text = match[1].trim();
                                const emotion = match[2].trim();
                                const tts_char = document.getElementById('choose-voice').value;
                                const output_name = keyIndex.toString() + '_' + fileIndex.toString();
                                // 发送数据到后端
                                sendToBackend(text, emotion, tts_char, output_name, savedLangValue, savedCutValue, savedVoiceSpeedValue, savedVoiceTempValue);
                            } else {
                                console.error('无法拆分文本和情绪:', selectedData);
                            }
                        } else {
                            console.error('未找到对应的数据');
                        }
                    } catch (error) {
                        console.error('重新生成片段时出错:', error);
                    }
                }
            });
            // // 语音片段合成
            // const audioApplyBtn = document.getElementById('audio-apply-btn');
            // audioApplyBtn.addEventListener('click', async function() {
            //     console.log('合成按钮被点击:');
            //     selectedSceneIndex_str = selectedSceneIndex.toString();
            //     try {
            //         const response = await fetch('/apply-audio-file', {
            //             method: 'POST',
            //             headers: {
            //                 'Content-Type': 'application/json'
            //             },
            //             body: JSON.stringify({ fileName: selectedSceneIndex_str })
            //         });
            //         if (!response.ok) {
            //             const errorData = await response.json(); // 获取错误信息
            //             throw new Error(`合成失败: ${errorData.detail || '未知错误'}`);
            //         }
            //         const data = await response.json();
            //         audioContainer.innerHTML = '';
            //         const fileName = data.fileName;
            //         console.log('合成的文件名:', data.audio_files);
            //         createAudioPlayer(fileName);
            //     } catch (error) {
            //         console.error('合成时出错:', error);
            //     }
            // });
            
            // 动作生成面板
            selectCharElement.addEventListener('change', function() {
                selectedCharValue = selectCharElement.value;
                console.log('选中的角色:', selectedCharValue);
                // 在这里可以添加其他处理逻辑，例如显示选中角色的详细信息
            });

            // 面板与遮罩
            const motionSettingPanel = document.getElementById('motion-setting-panel');
            motionGenBtn.addEventListener('click', async function() {
                UpdateMotiontext();
            });
            //更新动作面板的文字
            async function UpdateMotiontext()
            {
                try {
                    // 读取现有的 JSON 数据
                    const response = await fetch('/read-json-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            fileName: 'emotion_analysis.json'
                        })
                    });
                    const data = await response.json();
                    // 提取 selectedSceneIndex 对应的值
                    const selectedSceneData = data[selectedSceneIndex.toString()];
                    if (!selectedSceneData) {
                        console.error('未找到对应的 selectedSceneIndex 数据');
                        return;
                    }
                    // 清空 MotionContainer 的内容
                    const MotionContainer = document.getElementById('show-motion-panel');
                    MotionContainer.innerHTML = '';
                    // 遍历每个 selectedSceneData 的值
                    selectedSceneData.forEach((item, index) => {
                        const match = item.match(/^(.+)\((.+)\)$/);
                        if (match) {
                            const text = match[1].trim();
                            const emotion = match[2].trim();
                            const MotionContainer = document.getElementById('show-motion-panel');
                            MotionContainer.className = 'show-text-panel';
                            const MotionItem = document.createElement('div');
                            MotionItem.className = 'motion-item';
                            const textElement = document.createElement('span');
                            textElement.textContent = text;
                            MotionItem.appendChild(textElement);
                            const selectElement = document.createElement('select');
                            selectElement.className = 'motion-select';
                            // 创建默认选项
                            const defaultOption = document.createElement('option');
                            defaultOption.value = 'default';
                            defaultOption.textContent = '默认';
                            defaultOption.selected = true; 
                            selectElement.appendChild(defaultOption);
                            // 创建自定义选项
                            const customOption = document.createElement('option');
                            customOption.value = 'custom';
                            customOption.textContent = '自定义';
                            selectElement.appendChild(customOption);
                            // 添加事件监听器
                            selectElement.addEventListener('change', function() {
                                const fileName = `${selectedSceneIndex}_${this.dataset.index}.flac`;
                                const filePath = `data/audio/${fileName}`;
                                fetch(filePath, { method: 'HEAD' })
                                    .then(response => {
                                        if (response.ok) {
                                            // 文件存在，调用生成预览动作的函数
                                            if (this.value === 'custom') {
                                                handleCustomSelection(MotionItem, text, this.dataset.index,selectElement);
                                            }
                                        } else {
                                            alert('请先生成音乐文件！');
                                            console.error(`文件 ${fileName} 不存在`);
                                            loadingOverlay.style.display = 'none';
                                            return;
                                        }
                                    })
                                    .catch(error => {
                                        console.error(`检查文件 ${fileName} 时出错:`, error);
                                    });

                            });
                            // 设置自定义属性存储索引
                            selectElement.dataset.index = index;
                            MotionItem.appendChild(selectElement);
                            MotionContainer.appendChild(MotionItem);
                        } else {
                            console.error('无法拆分文本和情绪:', item);
                        }
                    });
                } catch (error) {
                    console.error('读取数据时出错:', error);
                }
            }
            //点击姿态预览按钮
            const motionpreviewbtn = document.getElementById('motion-pose-pre');
            motionpreviewbtn.addEventListener('click', async function() {
                let alertShown = false;
                console.log('预览动作');
                const MotionContainer = document.getElementById('show-motion-panel');
                const MotionItems = MotionContainer.getElementsByClassName('motion-item');
                try {
                    const audioFiles = await fetchAudioFiles();
                    console.log('获取到的音频文件:', audioFiles);
                    // 检查文件数量是否一致
                    if (audioFiles.length !== MotionItems.length) {
                        if (!alertShown) {
                            alert('音频文件数量与 MotionItems 数量不一致！');
                            alertShown = true;
                            loadingOverlay.style.display = 'none';
                            return;
                        }
                    }
                    // 依次执行 handleMotionPreview 函数
                    for (let i = 0; i < audioFiles.length; i++) {
                        const fileName = audioFiles[i].replace('.flac', '');
                        const selectElement = MotionItems[i].querySelector('.motion-select');
                        if (selectElement.value !== 'custom' && !alertShown) {
                            await handleMotionPreview(fileName);
                            UpdateMotionVideo(selectedSceneIndex.toString(), "motion-pre");
                        }
                    }
                } catch (error) {
                    console.error('获取音频文件列表时出错:', error);
                    if (!alertShown) {
                        alert('获取音频文件列表时出错！');
                        alertShown = true;
                        loadingOverlay.style.display = 'none';
                    }
                }
            });

            //获取动作文件列表
            async function getmotionfiles(selectedSceneIndex,folderName) {
                try {
                    const response = await fetch('/get-motion-files', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ selectedSceneIndex, folderName})
                    });
                    if (!response.ok) {
                        throw new Error('网络响应失败');
                    }
                    const data = await response.json();
                    //创建视频播放器
                    const motion_files = data.motion_files;
                    return motion_files;
                }
                catch (error) {
                    console.error('获取motion文件列表时出错:', error);
                }
            }
            //点击角色渲染预览按钮
            const motionrenderbtn = document.getElementById('motion-render-pre');
            motionrenderbtn.addEventListener('click', async function() {
                console.log('预览角色渲染');
                let alertShown = false;
                const MotionContainer = document.getElementById('show-motion-panel');
                const MotionItems = MotionContainer.getElementsByClassName('motion-item');
                try {
                    const motion_files = await getmotionfiles(selectedSceneIndex.toString(),"motion-pre");
                    console.log("获取到的动作文件:",motion_files);
                    // 检查文件数量是否一致
                    if (motion_files.length !== MotionItems.length) {
                        if (!alertShown) {
                            alert('音频文件数量与 MotionItems 数量不一致！');
                            alertShown = true;
                            loadingOverlay.style.display = 'none';
                            return;
                        }
                    }
                    // 依次执行 handleMotionPreview 函数
                    for (let i = 0; i < motion_files.length; i++) {
                        const fileName = motion_files[i].replace('.mp4', '');
                        const selectElement = MotionItems[i].querySelector('.motion-select');
                        if (!alertShown) {
                            await handleMotionRender(fileName,selectedCharValue);
                            UpdateMotionVideo(selectedSceneIndex.toString(),"motion");
                        }
                    }
                } catch (error) {
                    console.error('获取动作文件列表时出错:', error);
                    if (!alertShown) {
                        alert('获取动作文件列表时出错！');
                        alertShown = true;
                        loadingOverlay.style.display = 'none';
                    }
                }
            });

            // 生成默认动作-姿态预览动作-EMAGE
            async function handleMotionPreview(fileName) {
                const filename = fileName
                loadingOverlay.style.display = 'flex'; // 显示加载图标
                console.log(fileName)
                try {
                    const response = await fetch('/generate-defaultmotion', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ fileName: filename })
                    });
                    if (!response.ok) {
                        throw new Error('网络响应失败');
                    }
                    const data = await response.json();
                    console.log('读取到的数据:', data);
                }
                catch (error) {
                    console.error('读取数据时出错:', error);
                }
                finally {
                    loadingOverlay.style.display = 'none'; // 隐藏加载图标
                }
            }
            //生成角色渲染动作-Musepose
            async function handleMotionRender(fileName,selectedCharValue) {
                loadingOverlay.style.display = 'flex';
                const filename = fileName
                try {
                    const response = await fetch('/generate-charrender', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ fileName: filename, selectedCharValue: selectedCharValue })
                    });
                    if (!response.ok) {
                        throw new Error('网络响应失败');
                    }
                    const data = await response.json();
                    console.log('成功生成文件:', data.outputname);
                    const motionoutputname = data.outputname;
                    const FloderName = "motion"
                    //重命名并移动文件
                    const fileNameResponse = await fetch('/renameandmove-motion-file', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ motionoutputname, FloderName})
                    });
                    if (!fileNameResponse.ok) {
                        throw new Error('网络响应失败');
                    }
                    const fileNameData = await fileNameResponse.json();
                    console.log('重命名后的文件名:', fileNameData.fileName);
                }
                catch (error) {
                    console.error('读取数据时出错:', error);
                }
                finally {
                    loadingOverlay.style.display = 'none'; // 隐藏加载图标
                }
            }


            //更新预览
            async function UpdateMotionVideo(selectedSceneIndex, folderName)
            {
                const MotionPreviewPanel = document.getElementById('motion-preview-panel');
                MotionPreviewPanel.innerHTML = '';
                console.log('更新预览');
                try {
                    const response = await fetch('/get-motion-files', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ selectedSceneIndex, folderName})
                    });
                    if (!response.ok) {
                        throw new Error('网络响应失败');
                    }
                    const data = await response.json();
                    //创建视频播放器
                    const motion_files = data.motion_files;
                    console.log('创建视频播放器:', motion_files);
                    motion_files.forEach(fileName => createMotionPreviewPlayer(fileName,folderName));

                }
                catch (error) {
                    console.error('生成动作时出错:', error);
                }
            }
            //创建动作预览播放器
            async function createMotionPreviewPlayer(fileName,folderName) {
                const videoContainer = document.getElementById('motion-preview-panel');
                const videoElement = document.createElement('video');
                videoElement.src = `data/${folderName}/${fileName}`;
                console.log('创建动作预览播放器:', videoElement.src);
                videoElement.controls = true;
                videoElement.className='motion-pre-video';
                videoElement.muted = true;
                videoContainer.appendChild(videoElement);
            }
            // 打开动作设置面板
            async function handleCustomSelection(MotionItem, text, selectedIndex,selectElement) {
                overlay.style.display = 'block'; 
                motionSettingPanel.style.display = 'block';
                const motionTime = document.getElementById('motion-time');
                const duration = await getAudioDuration(selectedSceneIndex, selectedIndex);
                console.log('音频时长:', duration);
                motionTime.textContent = '视频时长：' + duration.toString() + 's';
                const motionindex = selectedIndex
                console.log('motionindex:', motionindex);
                // 将 motionindex 传递给 handleMotionGeneration 函数
                const motioncustomegenbtn = document.getElementById('save-motion-setting-btn');
                motioncustomegenbtn.addEventListener('click', async function() {
                    const motionGenPrompt = document.getElementById('motion-gen-prompt').value;
                    const motionLerpCheckbox = document.getElementById('motion-lerp');
                    const motionLerp = motionLerpCheckbox.checked ? 2 : 1;
                    const motionframe = Math.ceil(12 * duration)
                    handleMotionGeneration(selectedSceneIndex.toString(), motionindex, motionGenPrompt, motionLerp, motionframe);
                });
                const closemotionsetpanelbtn = document.getElementById('motion-set-close-btn');
                closemotionsetpanelbtn.addEventListener('click', function() {
                    overlay.style.display = 'none';
                    motionSettingPanel.style.display = 'none';
                    // 找到相应的 selectElement 并将其值设置为 'default'
                    if (selectElement) {
                        selectElement.value = 'default';
                    } 
                });
            }

            // 获取音频的时长作为动作时长
            async function getAudioDuration(selectedSceneIndex, selectedIndex) {
                const fileName = selectedSceneIndex.toString() + '_' + selectedIndex.toString() + '.flac';
                try {
                    const response = await fetch('/get-audio-length', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ fileName: fileName })
                    });
                    if (!response.ok) {
                        throw new Error('网络响应失败');
                    }
                    const data = await response.json();
                    const duration = data.length;
                    return duration;
                } catch (error) {
                    console.error('读取数据时出错:', error);
                }
            }

            // 生成自定义动作-MotionDiffuser
            async function handleMotionGeneration(selectedSceneIndex, motionindex, motionGenPrompt, motionLerp, motionframe) {
                loadingOverlay.style.display = 'flex'; // 显示加载图标
                const motionoutputname = selectedSceneIndex.toString() + '_' + motionindex.toString()
                try {
                    const response = await fetch('/generate-custommotion', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ motionoutputname, motionGenPrompt, motionLerp, motionframe})
                    });
                    if (response.ok) {
                        const data = await response.json();
                        console.log('动作生成成功',data.outputname);
                        //重命名并移动文件
                        const FloderName = "motion-pre";
                        const fileNameResponse = await fetch('/renameandmove-motion-file', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ motionoutputname,FloderName })
                        });
                        if (!fileNameResponse.ok) {
                            throw new Error('获取文件名失败');
                        }
                        const fileNameData = await fileNameResponse.json();
                        console.log('移动并重命名文件名:', fileNameData.fileName);
                        }
                        UpdateMotionVideo(selectedSceneIndex.toString(),"motion-pre");
                        
                } catch (error) {
                    console.error('生成动作时出错:', error);
                }
                finally {
                    loadingOverlay.style.display = 'none'; // 隐藏加载图标
                    overlay.style.display = 'none';
                    motionSettingPanel.style.display = 'none';
                    
                }
            }

            //口型匹配面板
            // 口型匹配滑块
            const slider1 = document.getElementById('slider1'); // 滑块1
            const tooltip1 = document.getElementById('tooltip1'); // Tooltip1
            const slider2 = document.getElementById('slider2'); // 滑块2
            const tooltip2 = document.getElementById('tooltip2'); // Tooltip2
            function updateTooltip(slider, tooltip) {
                const sliderRect = slider.getBoundingClientRect();
                const sliderWidth = slider.offsetWidth;
                const position = ((slider.value - slider.min) / (slider.max - slider.min)) * sliderWidth;
                tooltip.style.left = `${position - tooltip.offsetWidth / 2}px`; // 调整为 Tooltip 居中
                tooltip.textContent = slider.value; 
            }
            // 初始化 Tooltip 的位置和内容
            updateTooltip(slider1, tooltip1);
            updateTooltip(slider2, tooltip2);
            // 默认隐藏提示框
            tooltip1.style.opacity = 0;
            tooltip2.style.opacity = 0;
            // 监听滑块的拖动事件
            slider1.addEventListener('input', () => updateTooltip(slider1, tooltip1));
            slider2.addEventListener('input', () => updateTooltip(slider2, tooltip2));
            // 悬停时显示 Tooltip 并更新位置
            slider1.addEventListener('mouseenter', () => {
                updateTooltip(slider1, tooltip1);
                tooltip1.style.opacity = 1;
            });
            slider1.addEventListener('mouseleave', () => tooltip1.style.opacity = 0);

            slider2.addEventListener('mouseenter', () => {
                updateTooltip(slider2, tooltip2);
                tooltip2.style.opacity = 1;
            });
            slider2.addEventListener('mouseleave', () => tooltip2.style.opacity = 0);

            //点击口型匹配按钮
            const Lipshowpanel = document.getElementById('lip-show-panel');
            const charVideo = document.getElementById('char-video');
            const WavtoLipApplyBtn = document.getElementById('wavtolip-apply-btn');
            const WavtoLipEnsureBtn = document.getElementById('wavtolip-ensure-btn');
            WavtoLipApplyBtn.addEventListener('click', async function() {
                let alertShown = false;
                const MotionContainer = document.getElementById('show-motion-panel');
                const MotionItems = MotionContainer.getElementsByClassName('motion-item');
                try {
                    const motion_files = await getmotionfiles(selectedSceneIndex.toString(),"motion");
                    console.log("获取到的动作渲染文件:",motion_files);
                    // 检查文件数量是否一致
                    if (motion_files.length !== MotionItems.length) {
                        if (!alertShown) {
                            alert('音频文件数量与 MotionItems 数量不一致！');
                            alertShown = true;
                            loadingOverlay.style.display = 'none';
                            return;
                        }
                    }
                    // 依次执行口型匹配函数
                    for (let i = 0; i < motion_files.length; i++) {
                        const fileName = motion_files[i].replace('.mp4', '');
                        const selectElement = MotionItems[i].querySelector('.motion-select');
                        if (!alertShown) {
                            console.log(selectedCharValue);
                            await handleWavtoLipRender(fileName);
                        }
                    }
                    //拼合视频并显示面板
                    const mergefilename =  await MergeVideo();
                    charVideo.src = `data/char_video/${mergefilename}`;
                    Lipshowpanel.style.display = 'block';
                    WavtoLipEnsureBtn.style.display = 'block';
                    
                } catch (error) {
                    console.error('获取动作文件列表时出错:', error);
                    if (!alertShown) {
                        alert('获取动作文件列表时出错！');
                        alertShown = true;
                        loadingOverlay.style.display = 'none';
                    }
                }
            });
            //拼合视频函数
            async function MergeVideo() {
                loadingOverlay.style.display = 'flex';
                selectedSceneIndex = selectedSceneIndex.toString();
                selectedCharValue = selectedCharValue.split('.')[0];
                const MotionPreviewPanel = document.getElementById('motion-preview-panel');
                try {
                    const response = await fetch('/motion-apply', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ selectedSceneIndex,selectedCharValue})
                    });
                    if (response.ok) {
                        const data = await response.json();
                        console.log('动作拼合成功',data.fileName);
                        return data.fileName;
                    }
                }
                catch (error) {
                    console.error('生成动作时出错:', error);
                }
                finally {
                    loadingOverlay.style.display = 'none';
                }
            }

            // 口型匹配函数
            async function handleWavtoLipRender(filename) {
                loadingOverlay.style.display = 'flex';
                const bbox_shift = slider1.value;
                const batchsize = slider2.value;
                const fileName = filename;
                console.log('口型匹配模块:'+fileName);
                try {
                    const response = await fetch('/wavtolip', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ fileName,bbox_shift,batchsize})
                    });
                    if (response.ok) {
                        const data = await response.json();
                        const motionoutputname =data.outputname;
                        const FloderName ="char_video";
                        //重命名并移动文件
                        const fileNameResponse = await fetch('/renameandmove-motion-file', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ motionoutputname, FloderName})
                        });
                        if (!fileNameResponse.ok) {
                            throw new Error('网络响应失败');
                        }
                        const fileNameData = await fileNameResponse.json();
                        console.log('重命名后的文件名:', fileNameData.fileName);
                        }
                }
                catch (error) {
                    console.error('生成动作时出错:', error);
                }
                finally {
                    loadingOverlay.style.display = 'none';
                }
            }

            //删除冗余的动作数据
            async function deletmotiondata(selectedSceneIndex) {
                selectedSceneIndex = selectedSceneIndex.toString();
                try {
                    const response = await fetch('/delete-motion-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ selectedSceneIndex: selectedSceneIndex})
                    });
                    if (!response.ok) {
                        throw new Error('网络响应失败');
                    }
                    const data = await response.json();
                    console.log('删除动作数据成功');
                }
                catch (error) {
                    console.error('获取motion文件列表时出错:', error);
                }
            }

            //点击应用口型匹配按钮
            WavtoLipEnsureBtn.addEventListener('click', async function() {
                deletmotiondata(selectedSceneIndex);
                const mergefilename = selectedSceneIndex.toString();+"-"+selectedCharValue.split('.')[0];
                console.log("应用口型匹配按钮被点击"+mergefilename);
                getThisPageCharImages();
            });

            // 跳转->角色/素材生成
            const createcharbtn = document.getElementById('add-all-cha-btn');
            if (createcharbtn) {
                createcharbtn.addEventListener('click', function() {
                    window.location.href = 'create_char.html';
                });
            } else {
                console.error('Element with ID add-all-cha-btn not found');
            }
            const creatematbtn = document.getElementById('create-all-img-btn');
            if (creatematbtn) {
                creatematbtn.addEventListener('click', function() {
                    const description = selectedCameraItem.querySelector('.camera-description').textContent;
                    console.log("传输到角色界面的文案:" + description);
                    const data = encodeURIComponent(JSON.stringify({ text: description }));
                    window.location.href = `create_material.html?data=${data}`;
                });
            } else {
                console.error('Element with class .add-all-img-btn not found');
            }

            //视频编辑面板
            // //处理视频播放进度条
            // const video = document.getElementById('thispape-video');
            // const progress = document.getElementById('videoProgress');
            // const currentTimeDisplay = document.getElementById('currentTime');
            // const durationDisplay = document.getElementById('duration');
            // const playButton = document.getElementById('play-this-video'); 
            // const playIcon = document.getElementById('play-icon');
            // const frameRate = 24;
            // function formatTime(time) {
            //     const hours = Math.floor(time / 3600);
            //     const minutes = Math.floor((time % 3600) / 60);
            //     const seconds = Math.floor(time % 60);
            //     const frames = Math.floor((time % 1) * frameRate);
            //     return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${frames.toString().padStart(2, '0')}`;
            // }
            // video.addEventListener('timeupdate', () => {
            //     const value = (100 / video.duration) * video.currentTime;
            //     progress.value = value;
            //     currentTimeDisplay.textContent = formatTime(video.currentTime);
            //     updateFilledWidth(progress);
            // });

            // video.addEventListener('loadedmetadata', () => {
            //     durationDisplay.textContent = formatTime(video.duration);
            // });
            // progress.addEventListener('input', () => {
            //     const time = video.duration * (progress.value / 100);
            //     video.currentTime = time;
            //     updateFilledWidth(progress);
            // });
            // playButton.addEventListener('click', () => {
            //     if (video.paused) {
            //         video.play();
            //         playIcon.src = "images/btn_pause.png"; 
            //     } else {
            //         video.pause();
            //         playIcon.src = "images/btn_play.png"; 
            //     }
            // });
            // function updateFilledWidth(element) {
            //     element.style.setProperty('--filled-width', element.value + '%');
            // }
            // updateFilledWidth(progress);
            // video.addEventListener('ended', () => {
            //     playIcon.src = "images/btn_play.png";
            // });
            
            // 图片/视频转File
            async function createFileFromUrl(url, fileName) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error('Failed to fetch the image');
                    }
                    const blob = await response.blob();
                    return new File([blob], fileName, { type: blob.type });
                } catch (error) {
                    console.error('Error creating file from URL:', error);
                    throw error;
                }
            }
            //中文转英文ID
            function generateid(fileName) {
                if (fileName.includes('.')) {
                    var { pinyin } = pinyinPro;
                    fileName = fileName.split('.')[0];
                    const uniqueString = pinyin(fileName,{ toneType: 'none' });
                    const outputid = 'layer_'+uniqueString.replace(/\s+/g, '');
                    return outputid;
                }
            }
            const editor = document.getElementById('editor');
            editor.addEventListener('dragstart', function(event) {
                event.preventDefault();
            });
            let layers = []; // 存储所有图层的数组
            let selectedLayer = null; // 当前选中的图层

            // 选中图层
            editor.addEventListener('click', function(event) {
                const clickedLayer = event.target.closest('.layer');
                if (!clickedLayer && selectedLayer) {
                    selectedLayer.classList.remove('selected');
                    disableDraggable(selectedLayer);
                    disableResizable(selectedLayer);
                    disableRotatable(selectedLayer);
                    selectedLayer = null;
                }
            });
            function handleLayerClick(event) {
                const clickedLayer = event.currentTarget;
                if (selectedLayer) {
                    selectedLayer.classList.remove('selected');
                    disableDraggable(selectedLayer);
                    disableResizable(selectedLayer);
                    disableRotatable(selectedLayer);
                }
                clickedLayer.classList.add('selected');
                selectedLayer = clickedLayer;
                enableDraggable(selectedLayer);
                enableResizable(selectedLayer);
                enableRotatable(selectedLayer);
            }

            // 当前素材-素材库添加到当前素材列表
            async function addImageToPartMaterial(fileName) {
                selectedSceneIndex = selectedSceneIndex.toString();
                console.log('添加到当前素材列表', fileName);
                try {
                    const response = await fetch('/read-json-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            fileName: 'Material_data.json'
                        })
                    });
                    const data = await response.json();
                    if (!data[selectedSceneIndex]) {
                        data[selectedSceneIndex] = [];
                    }
                    let newFileName = fileName;
                    let index = 1;
                    while (data[selectedSceneIndex].includes(newFileName)) {
                        // 提取文件名和扩展名
                        const nameParts = fileName.split('.');
                        const name = nameParts.slice(0, -1).join('.'); // 文件名部分
                        const extension = nameParts[nameParts.length - 1]; // 扩展名部分
                        // 生成新的文件名
                        newFileName = `${name}${index}.${extension}`;
                        index++;
                    }
                    // 添加新的文件名到数组中
                    data[selectedSceneIndex].push(newFileName);
                    if (newFileName !== fileName) {
                        console.log(`文件名已更改：${fileName} -> ${newFileName}`);
                    }
                    // 将更新后的数据写回到 JSON 文件中
                    const updateResponse = await fetch('/save-json-data', {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            Jsondata: data,
                            fileName: 'Material_data.json'
                        })
                    });
                    if (!updateResponse.ok) {
                        throw new Error('更新数据失败');
                    }
                    getThisPageMatImages(); // 获取当前素材列表
                    console.log('添加的fileName',newFileName);
                    await addVideoMaterial('material',newFileName,selectedSceneIndex.toString());
                } catch (error) {
                    console.error('There was a problem with the fetch operation:', error);
                }
            }

            //初始化视频编辑器素材列表
            async function getThisPageVideoMaterial() {
                try {
                    const response = await fetch('/read-json-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            fileName: 'Material_data.json'
                        })
                    });
                    if (!response.ok) {
                        throw new Error('Failed to fetch JSON data');
                    }
                    const data = await response.json();
                    // 遍历 data 对象中的每个分镜
                    for (const [sceneIndex, filenames] of Object.entries(data)) {
                        // 检查 filenames 是否存在且为数组
                        if (Array.isArray(filenames)) {
                            for (const fileName of filenames) {
                                await addVideoMaterial('material',fileName,sceneIndex);
                            }
                        } else {
                            console.warn(`data for scene ${sceneIndex} is not an array or is empty:`, filenames);
                        }
                    }
                } catch (error) {
                    console.error('There was a problem with the fetch operation:', error);
                }
            }

            // 删除一个图层
            function removeLayer(newfileName) {
                console.log('removeLayer', newfileName);
                const layerId = generateid(newfileName);
                const layer = document.querySelector(`#${layerId}`);
                console.log('removeLayer', layerId);
                if (layer) {
                    layer.remove();
                    layers = layers.filter(l => l.id !== layerId);
                    console.log('Layer removed:', layerId);
                } else {
                    console.warn('Layer not found:', layerId);
                }
            }
            //创建图层-当前素材
            async function addVideoMaterial(Flodername, newFileName, sceneIndex) {
                if (!newFileName) {
                    console.error('Invalid newFileName:', newFileName);
                    return;
                }
                const fileName = newFileName.replace(/(\d+)(?=\.\w+$)/, '');
                const imageUrl = `data/${Flodername}/${encodeURIComponent(fileName)}`;
                try {
                    const file = await createFileFromUrl(imageUrl, fileName);
                    const layerId = generateid(newFileName);
                    const layerSceneIndex = sceneIndex;
                    // 获取 layerIndex
                    const response = await fetch('/read-json-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            fileName: 'Material_data.json'
                        })
                    });
                    const data = await response.json();
                    const filenames = data[selectedSceneIndex.toString()];
                    let layerIndex = filenames.indexOf(newFileName);
                    // 如果是角色，图层设置为100
                    if (layerIndex === -1 && Flodername === 'char_video') {
                        layerIndex = 100;
                    }
                    // 检查 layers 数组中是否已经存在具有相同唯一标识的 layer
                    const existingLayer = layers.find(existingLayer =>
                        existingLayer.id === layerId && existingLayer.getAttribute('sceneindex') === layerSceneIndex
                    );
                    if (existingLayer) {
                        console.log('existingLayer');
                        const initialStyles = {
                            top: existingLayer.style.top,
                            left: existingLayer.style.left,
                            width: existingLayer.style.width,
                            height: existingLayer.style.height,
                            transform: existingLayer.style.transform || 'rotate(0deg)' // 确保 transform 属性存在
                        };
                        existingLayer.remove();
                        const layer = createLayer(file, initialStyles, layerSceneIndex, layerIndex, layerId);
                        // 更新 layers 数组
                        const index = layers.indexOf(existingLayer);
                        if (index !== -1) {
                            layers[index] = layer;
                        }
                        console.log('Layer updated:');
                    } else {
                        // 创建新的 layer 并应用默认样式
                        const layer = createLayer(file, {}, layerSceneIndex, layerIndex, layerId);
                        layers.push(layer);
                        console.log('Layer added:');
                    }
                    // 更新视频编辑器
                    const currentSceneLayers = layers.filter(layer => layer.getAttribute('sceneindex') === selectedSceneIndex.toString());
                    const editor = document.getElementById('editor');
                    editor.innerHTML = ''; // 清空 editor
                    currentSceneLayers.sort((a, b) => {
                        const aIndex = parseInt(a.getAttribute('layerindex'), 10);
                        const bIndex = parseInt(b.getAttribute('layerindex'), 10);
                        return aIndex - bIndex;
                    });                    
                    currentSceneLayers.forEach(layer => {
                        editor.appendChild(layer);
                    });
                } catch (error) {
                    console.error('Error adding image from URL:', error);
                }
            }
            // 创建一个图层
            function createLayer(file, initialStyles = {}, layerSceneIndex, layerIndex, layerID) {
                const layer = document.createElement('div');
                layer.className = 'layer';
                layer.id = layerID;
                layer.setAttribute('data-name', file.name);
                layer.setAttribute('sceneindex', layerSceneIndex);
                layer.setAttribute('layerindex', layerIndex); // 设置 layerindex 属性（小写）
                // 添加点击事件监听器
                layer.addEventListener('click', handleLayerClick);
                // 应用初始样式
                Object.assign(layer.style, initialStyles);
                // 创建图片或视频元素
                const reader = new FileReader();
                reader.onload = function(e) {
                    if (file.type.startsWith('image')) {
                        const img = document.createElement('img');
                        img.src = e.target.result;
                        img.onload = function() {
                            img.style.width = '100%';
                            img.style.height = '100%';
                            layer.appendChild(img);
                            // 创建调整大小的锚点
                            const resizers = createResizers();
                            resizers.forEach(resizer => layer.appendChild(resizer));
                            // 创建旋转按钮
                            const rotateButton = createRotateButton();
                            layer.appendChild(rotateButton);
                            makeDraggable(layer);
                            makeResizable(layer);
                            makeRotatable(layer, rotateButton); 
                        };
                    } else if (file.type.startsWith('video')) {
                        const video = document.createElement('video');
                        video.controls = true;
                        video.src = e.target.result;
                        video.onloadedmetadata = function() {
                            // 应用初始样式
                            Object.assign(video.style, initialStyles);
                            layer.appendChild(video);
                            // 创建调整大小的锚点
                            const resizers = createResizers();
                            resizers.forEach(resizer => layer.appendChild(resizer));
                            // 创建旋转按钮
                            const rotateButton = createRotateButton();
                            layer.appendChild(rotateButton);
                            makeDraggable(layer);
                            makeResizable(layer);
                            makeRotatable(layer, rotateButton); 
                        };
                    }
                };
                reader.readAsDataURL(file);
                return layer;
            }
            // 创建旋转按钮
            function createRotateButton() {
                const rotateButton = document.createElement('div');
                rotateButton.className = 'rotate-button';
                return rotateButton;
            }
            // 创建调整大小的锚点
            function createResizers() {
                const resizerTL = document.createElement('div');
                resizerTL.className = 'resizer resizer-top-left';
                const resizerBR = document.createElement('div');
                resizerBR.className = 'resizer resizer-bottom-right';
                return [resizerTL, resizerBR];
            }
            // 旋转功能
            function makeRotatable(layer, rotateButton) {
                rotateButton.addEventListener('mousedown', handleRotateStart);
            }
            function handleRotateStart(event) {
                event.preventDefault(); // 防止默认行为
                const layer = event.currentTarget.closest('.layer');
                const rotateButton = event.currentTarget;
                const centerX = layer.offsetLeft + layer.offsetWidth / 2;
                const centerY = layer.offsetTop + layer.offsetHeight / 2;
                const offsetX = event.clientX - centerX;
                const offsetY = event.clientY - centerY;
                disableDraggable(layer);
                disableResizable(layer);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
                let initialAngle = 0;
                if (layer.style.transform) {
                    const match = layer.style.transform.match(/rotate\(([\d.]+)deg\)/);
                    if (match) {
                        initialAngle = parseFloat(match[1]);
                    }
                }
                function onMouseMove(event) {
                    const deltaX = event.clientX - centerX;
                    const deltaY = event.clientY - centerY;
                    const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI); // 计算角度
                    const rotateAngle = angle - Math.atan2(offsetY, offsetX) * (180 / Math.PI) + initialAngle;
                    layer.style.transform = `rotate(${rotateAngle}deg)`; // 应用旋转
                }
                function onMouseUp() {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    enableDraggable(layer);
                    enableResizable(layer);
                }
            }
            // 禁用/恢复旋转
            function disableRotatable(layer) {
                const rotateButton = layer.querySelector('.rotate-button');
                if (rotateButton) {
                    rotateButton.removeEventListener('mousedown', handleRotateStart);
                }
            }
            function enableRotatable(layer) {
                const rotateButton = layer.querySelector('.rotate-button');
                if (rotateButton) {
                    rotateButton.addEventListener('mousedown', handleRotateStart);
                }
            }
            // 拖拽逻辑
            function makeDraggable(layer) {
                layer.addEventListener('mousedown', handleDragStart);
            }
            function handleDragStart(event) {
                const layer = event.currentTarget;
                const offsetX = event.clientX - layer.offsetLeft;
                const offsetY = event.clientY - layer.offsetTop;
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
                disableResizable(layer);
                disableRotatable(layer);

                function onMouseMove(event) {
                    const newLeft = event.clientX - offsetX;
                    const newTop = event.clientY - offsetY;
                    layer.style.left = newLeft + 'px';
                    layer.style.top = newTop + 'px';
                }

                function onMouseUp() {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    enableResizable(layer);
                    enableRotatable(layer);
                }
            }
            // 禁用/恢复拖拽
            function disableDraggable(layer) {
                layer.removeEventListener('mousedown', handleDragStart);
            }
            function enableDraggable(layer) {
                layer.addEventListener('mousedown', handleDragStart);
            }

            // 调整大小逻辑
            function makeResizable(layer) {
                const resizers = layer.querySelectorAll('.resizer');
                resizers.forEach(resizer => {
                    resizer.addEventListener('mousedown', handleResize);
                });
            }
            function handleResize(event) {
                const layer = event.currentTarget.closest('.layer');
                const resizer = event.currentTarget;
                const startX = event.clientX;
                const startY = event.clientY;
                const startWidth = layer.offsetWidth;
                const startHeight = layer.offsetHeight;
                const startLeft = layer.offsetLeft;
                const startTop = layer.offsetTop;
                const startRatio = startWidth / startHeight;
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
                disableDraggable(layer);
                disableRotatable(layer);
                function onMouseMove(event) {
                    const deltaX = event.clientX - startX;
                    const deltaY = event.clientY - startY;
                    if (resizer.classList.contains('resizer-bottom-right')) {
                        let newWidth, newHeight;
                        if (event.shiftKey) {
                            newWidth = Math.max(10, startWidth + deltaX);
                            newHeight = newWidth / startRatio;
                            if (newHeight < 10) {
                                newHeight = 10;
                                newWidth = newHeight * startRatio;
                            }
                        } else {
                            newWidth = Math.max(10, startWidth + deltaX);
                            newHeight = Math.max(10, startHeight + deltaY);
                        }
                        layer.style.width = newWidth + 'px';
                        layer.style.height = newHeight + 'px';
                        // 更新图片的宽高
                        const img = layer.querySelector('img');
                        const video = layer.querySelector('video');
                        if (img) {
                            img.style.width = '100%';
                            img.style.height = '100%';
                        } else if (video) {
                            video.style.width = '100%';
                            video.style.height = '100%';
                        }
                    } else if (resizer.classList.contains('resizer-top-left')) {
                        let newWidth, newHeight;
                        if (event.shiftKey) {
                            newWidth = Math.max(10, startWidth - deltaX);
                            newHeight = newWidth / startRatio;
                            if (newHeight < 10) {
                                newHeight = 10;
                                newWidth = newHeight * startRatio;
                            }
                        } else {
                            newWidth = Math.max(10, startWidth - deltaX);
                            newHeight = Math.max(10, startHeight - deltaY);
                        }
                        // 更新图层的宽高和位置
                        layer.style.width = newWidth + 'px';
                        layer.style.height = newHeight + 'px';
                        layer.style.left = (startLeft - deltaX) + 'px';
                        layer.style.top = (startTop - deltaY) + 'px';
                        // 更新图片的宽高
                        const img = layer.querySelector('img');
                        const video = layer.querySelector('video');
                        if (img) {
                            img.style.width = '100%';
                            img.style.height = '100%';
                        } else if (video) {
                            video.style.width = '100%';
                            video.style.height = '100%';
                        }
                    }
                }
                function onMouseUp() {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    enableDraggable(layer);
                    enableRotatable(layer);
                }
            }
            // 禁用/恢复调整大小
            function disableResizable(layer) {
                const resizers = layer.querySelectorAll('.resizer');
                resizers.forEach(resizer => resizer.removeEventListener('mousedown', handleResize));
            }
            function enableResizable(layer) {
                const resizers = layer.querySelectorAll('.resizer');
                resizers.forEach(resizer => resizer.addEventListener('mousedown', handleResize));
            }

            // 导出视频按钮点击事件
            document.getElementById('preview-btn').addEventListener('click', function() {
                // 过滤掉无效的图层
                const validLayers = layers.filter(layer => layer instanceof HTMLElement);
                const layerData = validLayers.map(layer => ({
                    scene: layer.getAttribute('sceneindex'),
                    type: layer.querySelector('img') ? 'image' : 'video',
                    src: `./static/data/material/${layer.getAttribute('data-name')}`,
                    position: {
                        top: layer.style.top,
                        left: layer.style.left
                    },
                    size: {
                        width: layer.style.width,
                        height: layer.style.height
                    },
                    transform: layer.style.transform || 'rotate(0deg)', // 添加旋转角度
                    layerIndex: parseInt(layer.getAttribute('layerindex')) // 添加 layerIndex 属性
                }));
                console.log("layerData", layerData);
                
                // fetch('/export_video', {
                //     method: 'POST',
                //     headers: {
                //         'Content-Type': 'application/json'
                //     },
                //     body: JSON.stringify({ layers: layerData })
                // }).then(response => response.json())
                // .then(data => {
                //     alert('视频导出成功: ' + data.url);
                // })
                // .catch(error => {
                //     console.error('导出失败:', error);
                // });
            });
        });
</script>

</body>
</html>